---
title: react-query 알아보기
date: 2025-09-05 17:00:00
summary: react-query의 개념과 사용법에 대하여
---

프론트엔드는 필요할 때 백엔드 API에 데이터를 요청하고 응답을 받아와 화면을 그림

리액트에서는 주로 useEffect를 활용해 이를 구현

그런데 로딩이나 에러등의 처리를 위해 상태를 추가하기 시작하다보면 API 처리 로직이 복잡해짐

react-query가 등장하게 됨

이 글에서는 react-query의 개념과 기본적인 사용법에 대해 정리해보고자 함

### react-query?

리액트에서 API를 호출할 때 useEffect를 사용해서 주로 핸들링함

데이터 패칭 도중 로딩을 표현하고 싶으면 상태를 추가해 표현함

그리고 도중에 발생하는 에러를 처리하기 위한 상태를 추가하기도 함

(예시 코드)

그렇게 필요한 기능들을 계속 추가하다보면 API 하나 처리하는데 너무 많은 상태를 관리하게 되기 시작하면서 복잡해짐.

커스텀 훅을 정의하게 되면 어느정도 해결이 가능함

하지만 동일한 요청에 대해 중복 요청을 방지하고 싶을 수 있는데, 이를 직접 구현하기엔 너무 복잡해질 수 있음

이렇게 프론트엔드에서 API를 처리하는 데에 다양한 요구사항이 생기게 되었고, 이를 해결하고자 react-query가 등장하게 됨

react-query는 API 처리 과정에서 필요할 수 있는 상태부터 캐싱 기능까지 다양한 기능을 제공함.

### react-query

우선 react-query를 사용하기 위해서는 기본 설정을 해줘야 함.

react-query는 다음과 같이 설치할 수 있음. Tanstack으로 변경되어 `@tanstack/react-query`로 설치해야 함.

```bash
npm install @tanstack/react-query
```

react-query는 동일한 요청을 캐싱하고 재사용한다. 이를 위해 내부적으로 React의 Context API를 활용하며, 추가적인 설정을 해주어야 함.

QueryClient라는 객체를 생성하고, QueryClientProvider를 통해 이 객체를 제공해야 함.

(예제 코드)

QueryClient는 react-query의 핵심 객체로 다음과 같은 역할을 담당한다

- 캐시 관리 : 쿼리 데이터를 캐싱하고, 캐시된 데이터를 관리함.
- 무효화, 대요청 : 특정 쿼리를 무효화하거나, 다시 데이터를 가져오도록 함.
- 전역 설정 : 쿼리의 기본 설정을 지정할 수 있음.

예를 들어, 쿼리의 기본 캐시 시간을 설정해 전역적으로 적용할 수 있음.

(예제 코드)

이렇게 설정하면, 프로젝트의 Provider 하위 컴포넌트에서 react-query의 훅을 사용할 수 있게 됨.

이제 react-query의 주요 기능들에 대해 알아보자.

### useQuery

`useQuery`는 react-query에서 가장 기본이 되는 훅으로, 데이터를 가져오기 위한 기본 도구임.

API 요청을 처리하면서도 로딩, 에러, 데이터 상태를 자동으로 관리해주기 떄문에 `useEffect`와 `useState`를 직접 조합하는 것보다 훨씬 간결함.

(예제 코드)

코드는 훅에 옵션을 전달하고, 반환된 상태를 활용해 로딩, 에러, 데이터를 처리함.

`useQuery`는 다음과 같은 상태를 반환함

반환값 몇 개 설명(isLoading, isError, data, error, refetch )

isLoading, isFetching 차이

`useQuery`는 다음과 같은 인자를 받음

인자 몇 개 설명( queryKey, queryFn, select, enabled )

쿼리 키 설명 및 설계

- 문자열 vs 배열
- 배열에 변수도 적용할 수 있음

queryFn 설명

select 설명

enabled 설명

placeholderData 설명

initialData 설명

이를 활용한다면, API를 호출해 데이터를 가져오는 작업을 훨씬 깔끔하게 선언할 수 있고, 필요한 상태를 쉽게 활용할 수 있음.

### useMutation

`useQuery`가 데이터를 조회하는데 사용된다면, `useMutation`은 데이터를 생성, 수정, 삭제하는데 사용됨.

`useQuery`와 달리 `useMutation`은 호출 시점에 데이터를 가져오는 것이 아니라, 반환되는 함수를 호출해 데이터를 처리함.

또한, 생성, 수정, 삭제의 경우에는 일반적으로 서버의 데이터를 변경하는 작업이므로, 요청에 대한 캐싱은 수행되지 않는다는 특징이 있다.

(예제 코드)

반환값 설명

- mutate, mutateAsync 및 두 개의 차이점
- isLoading, isError, isSuccess, data, error, isIdle

`useMutation`은 다음과 같은 인자를 받음

- onSuccess, onError, onSettled
- variables

이를 활용해, API를 호출하는 행위를 훨씬 간결하게 선언할 수 있고, 필요한 상태를 쉽게 활용할 수 있음.

### 캐싱

캐싱은 동일한 요청을 반복적으로 호출할 때, 이미 가져온 데이터를 재사용하는 기능임. 이를 활용한다면 불필요한 네트워크 요청을 줄이는 데에 도움을 줌.

react-query는 요청에 대한 응답을 자동으로 캐싱하며, 동일한 요청에 대해 캐시된 데이터를 반환하는 기능을 가지고 있다.

캐싱은 queryClient 단위로 관리되며, queryClient를 제공한 Provider 하위 컴포넌트에 공유된다.

캐싱은 `queryKey`를 기준으로 관리되며, 동일한 `queryKey`에 대해 캐시된 데이터를 재사용함.

캐싱 상태 및 기본 개념( fresh, stale, inactive, garbage collected )

추가로 stale 일 때 refetch 되는 타이밍

- stale 상태에서 컴포넌트 마운트
- stale 상태에서 윈도우 포커스/네트워크 재연결
- 수동 호출(refetch)

staleTime, gcTime(cacheTime) 설명

(캐싱 다이어그램 - fresh, stale, inactive, garbage collected 상태 변화)

데이터 받아오면 fresh, 시간 지나면 stale, refetch되면 다시 fresh됨

이 때, 스테일이 된 데이터를 요청하면 바로 캐시된 데이터 반환 + 백그라운드에서 refetch 실행해 데이터를 갱신

(캐싱 다이어그램 - 스테일타임이 지나기 전과, 지난 후의 작동 방식)

이는 이전 데이터라도 빠르게 보여주면서, 백그라운드에서 최신 데이터를 가져와 갱신하는 UX를 제공함

그리고 모든 컴포넌트의 구독이 끊기면 inactive, 일정 시간 지나면 garbage collected

캐싱을 이해하면 react-query의 동작을 이해하는데 많은 도움이 됨.

react-query는 단순히 데이터를 저장하는데 그치지 않고, 신선도를 관리하면서 네트워크 요청을 최적화한다는 점을 알 수 있음

하지만 캐시된 데이터는 서버의 데이터와 다를 수 있음. 새로운 데이터가 서버에 반영되었을 때, 캐시된 데이터는 여전히 이전 상태일 수 있음.

그래서 필요에 따라 캐시를 무효화하거나 다시 데이터를 가져오는 전략이 필요함.

### 쿼리 무효화 전략

앞서 살펴본 것 처럼, react-query는 데이터를 캐싱함. 하지만 서버의 데이터가 변경되었을 때, 캐시된 데이터는 더 이상 유효하지 않을 수 있음.

그래서 react-query는 쿼리의 캐시를 무효화하거나, 직접 다시 호출하는 기능을 제공함.

이를 적절히 활용한다면, 서버와 클라이언트의 데이터 일관성을 유지하는데 도움을 줄 수 있음.

invalidateQueries는 특정 쿼리 키에 해당하는 캐시를 무효화시킴. 즉, stale 상태로 전환시킴

그리고 다음번에 해당 쿼리를 사용하는 컴포넌트가 마운트되거나 refetch가 발생할 때 때 다시 데이터를 가져오도록 함.

(예제 코드)

refetchQueries는 특정 쿼리 키에 해당하는 쿼리를 즉시 다시 호출함

그래서 invalidateQueries와 달리, 즉시 데이터를 갱신하고자 할 때 사용됨.

(예제 코드)

정리하자면, invalidateQueries는 캐시를 무효화시키고, 다음번에 다시 데이터를 가져오도록 함. refetchQueries는 즉시 데이터를 다시 가져오도록 함.

따라서 변경된 정보를 빠르게 반영하고자 할 때는 refetchQueries를, 다음번에 데이터를 다시 가져오도록 하고 싶을 때는 invalidateQueries를 사용하는 것이 적절함.

이 두 가지 전략을 상황에 맞게 활용한다면 캐싱된 데이터와 실제 서버 데이터를 효과적으로 일치시킬 수 있음.

### 핵심 사용 흐름

지금까지 react-query의 주요 기능들을 살펴 보았다.

useQuery를 통해 데이터를 조회하고, useMutation을 통해 데이터를 생성, 수정, 삭제할 수 있다는 것을 알게 되었다. 그리고 react-query의 캐싱 메커니즘과 함께 이를 무효화할 수 있는 전략도 알아보았다.

이들은 각각의 기능만으로 충분히 유용한 기능을 제공한다. 하지만 함께 조합해서 사용할 경우 더욱 강력한 기능을 발휘할 수 있다.

특정 데이터를 불러오는 쿼리가 있고, 이 데이터를 수정하는 뮤테이션이 있다고 가정해보자.

(예제 코드)

데이터를 수정하는 뮤테이션이 성공적으로 완료되면, 위의 쿼리를 업데이트하여 최신 상태를 반영하고 싶을 수 있음.

이런 경우 갱신 하고 싶은 `useQuery`에서 반환된 `refetch` 함수를 호출해 데이터를 다시 가져오도록 할 수 있음.

(예제 코드)

하지만 `refetch`를 직접 호출할 수 없는 경우, 예를 들어 `useQuery`와 `useMutation`이 서로 다른 컴포넌트에 있을 때는 어떻게 해야 할까? 아니면 여러 개의 쿼리를 한 번에 갱신하고 싶을 때는?

이 때 바로 invalidateQuery와 refetchQueries를 활용할 수 있다.

(예제 코드)

뮤테이션이 완료됬을 때, queryClient의 invalidateQueries를 호출해 특정 쿼리를 무효화시킨다. 그러면 해당 쿼리의 캐시는 stale 상태가 되고, 특정 시점에 업데이트 되며 최신 데이터를 반영하게 된다. 혹은 refetchQueries를 호출해 즉시 데이터를 다시 가져오도록 할 수도 있다.

결국 `useQuery`, `useMutation`, 그리고 쿼리 무효화는 하나의 사이클을 형성해 서로 연동될 수 있다. `useQuery`는 데이터를 가져와 화면에 보여주고, `useMutation`은 사용자의 동작을 서버에 반영하며, 쿼리 무효화는 변경된 결과가 다시 조회되도록 하는 역할을 한다.

이 세가지가 맞물려 동작할 때, 데이터를 불러오고 수정하고 최신 상태를 반영하는 과정이 매끄럽게 이어지며 클라이언트와 서버 간 데이터 일관성을 자연스럽게 유지할 수 있는 흐름을 만들어준다.

실제로 간단한 TODO 리스트를 통해서 실제 흐름을 한 번 확인해보자.

- 핵심 사용 흐름
  - useQuery로 데이터 호출
  - useMutation으로 데이터 호출
  - invalidateQueries로 캐시 무효화

### 마무리

이번 글에서는 react-query를 공부하면서 알게 된 내용을 정리해보았음.

처음에 react-query는 단순하게 API 처리를 편하게 하는 도구로만 생각했음. 사이드 프로젝트에 도입하기도 했는데, 그 때에도 단순히 캐싱 기능을 활용하는 정도로만 사용했음

그런데 생각보다 많은 기능과 활용도가 있다는 것을 알게 되었고, 엄청 유용한 도구라는 생각을 하게 되었음. 특히 서버와 클라이언트의 데이터 일관성을 유지하는데 많은 도움을 줄 수 있다는 점이 인상적이었음.

react-query에 대한 기능을 사용해볼 수 있는 기회가 있었으면 좋겠음

시간이 된다면, 이 글에서 다루지 못했던 react-query를 활용한 더 다양한 기능에 대해서도 정리해보고 싶음
