---
title: react-query 알아보기
date: 2025-09-05 17:00:00
summary: react-query의 개념과 사용법에 대하여
---

진행하고 있던 사이드 프로젝트를 고도화하기 위해 다양한 작업을 진행하고 있었다. 프로젝트는 Next.js 기반으로, 데이터를 API로 요청하는 구간은 상황에 따라서 서버, 클라이언트 컴포넌트를 적절히 섞어서 사용하고 있었다.

Next.js는 `fetch`를 확장하여 캐싱 기능을 제공한다. 그래서 서버 렌더링 과정에서의 불필요한 중복 요청을 줄이고자 요청 함수들을 axios에서 `fetch`로 변경하는 작업을 진행했다. 하지만 클라이언트 컴포넌트에서는 Next.js의 `fetch`를 사용할 수 없기 때문에, 클라이언트 컴포넌트에서의 API 요청 최적화는 별도로 진행해야 했다.

또한, 클라이언트 컴포넌트에서는 `useEffect`와 `useState`를 조합하여 API 요청을 처리하고 있었는데, 로딩이나 에러 처리를 위해 상태를 추가하며 점점 복잡해지고 있던 상황이었다.

그러다 react-query 라이브러리가 떠올랐고, 이를 활용하면 API 요청을 훨씬 간결하게 처리할 수 있고 캐싱을 통한 최적화가 가능하다는 것이 생각났다. 그래서 사이드 프로젝트에 도입하게 되었는데, 학습하는 과정에서 생각보다 많은 기능과 활용도가 있다는 것을 알게 되었다.

이 글에서는 react-query의 기본적인 개념과 그 사용법에 대해 정리해 보고자 한다.

### react-query?

리엑트의 컴포넌트에서 API를 호출할 때에는 주로 `useEffect`를 사용하여 데이터를 패칭하고, `useState`를 사용하여 상태를 관리하는 패턴을 많이 사용한다. 그리고 그 과정에서 로딩을 표현하고 싶거나, 에러를 처리하고 싶을 때에는 상태를 추가하여 핸들링하는 경우가 많다.

```ts
useEffect(() => {
  async function fetchData() {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch("/api/data");
      const result = await response.json();
      setData(result);
    } catch (error) {
      setError(error);
    } finally {
      setIsLoading(false);
    }
  }

  fetchData();
}, []);
```

위 코드는 `useEffect`를 사용하여 컴포넌트가 마운트될 때 API를 호출하고, 로딩 상태와 에러 상태를 관리하는 간단한 예시이다. 단순한 API 호출 정도는 이 방식으로 충분히 처리할 수 있다.

하지만, 한 컴포넌트 안에서 여러 개의 API를 호출하는 경우에는 각 API마다 로딩, 에러, 데이터 상태를 관리해야 하므로 상태가 늘어나게 되어 코드가 복잡해지기 시작한다. 이 경우 커스텀 훅을 정의하여 상태 관리를 어느 정도 해결할 수 있다.

```ts
const [data, isLoading, error] = useFetch("/api/data");
```

커스텀 훅을 정의해 API 호출 처리를 추상화할 수는 있다. 하지만 필요한 기능들을 계속 추가하다 보면, API 하나를 처리하는데 너무 많은 상태를 관리하게 되거나, 원하는 기능을 직접 구현하기에는 너무 복잡해질 수 있다.

- 캐싱 : 동일한 요청에 대해 중복 요청을 방지하고 싶다.
- 리페칭 : 특정 시점에 데이터를 다시 가져오고 싶다.
- 조건부 요청 : 특정 조건에서만 요청을 보내고 싶다.

이렇게 프론트엔드에서 API를 처리하는 데에 여러 요구사항이 생기게 되면서, 그 처리 역시 복잡해지기 시작했다. 이런 다양한 상황을 해결하고자 react-query가 등장하게 되었다.

react-query는 API 처리 과정에서 필요할 수 있는 상태를 제공하는 것 부터, 요청에 대한 응답을 캐싱해 재사용하는 기능까지 다양한 기능을 제공한다. 그래서 이를 활용한다면 API 요청을 훨씬 간결하게 처리할 수 있고, 불필요한 네트워크 요청을 줄이는 데에도 도움을 줄 수 있다.

### react-query 기본 설정

react-query는 다음과 같이 설치할 수 있다. Tanstack으로 프로젝트가 이전되었기 때문에 `@tanstack/react-query` 패키지를 설치해야 한다.

```bash
npm install @tanstack/react-query
```

사용하기에 앞서, react-query의 기본 설정을 해주어야 한다.

react-query는 동일한 요청을 캐싱하고 재사용한다. 이를 위해 내부적으로 React의 Context API를 활용하는데, 따라서 앱의 루트에 Provider를 설정해주어야 한다.

먼저 `QueryClient`라는 객체를 생성하고, 앱을 `QueryClientProvider`로 감싸고 객체를 하위 컴포넌트에 전달해주도록 해야 한다.

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* 앱 컴포넌트 */}
    </QueryClientProvider>
  );
}
```

`QueryClient`는 react-query의 핵심 객체로, 다음과 같은 역할을 담당한다.

- 캐시 관리 : 쿼리 데이터를 캐싱하고 관리하며, 필요할 때 재사용한다.
- 무효화, 재요청 : 특정 쿼리를 무효화하거나 다시 데이터를 가져올 수 있다.
- 전역 설정 : 쿼리의 기본 설정을 지정할 수 있다.

예를 들어, 특정 옵션을 설정해 전역적으로 적용할 수 있다.

```ts
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5 // 캐시를 5분 동안 유지한다.
    }
  }
});
```

이렇게 설정하면, 다음에 설명할 `useQuery` 훅을 사용할 때, 별도로 `staleTime`을 지정하지 않으면 기본적으로 5분 동안 캐시가 유지된다. 이 외에도 쿼리와 뮤테이션에 대한 다양한 기본 옵션을 지정할 수 있다.

`QueryClient`는 앱 전체에서 하나만 생성하여 사용하는 것이 일반적이다. 여러 개를 생성하여 사용할 수도 있지만, 그렇게 할 경우 캐시가 분리되어 관리되므로 주의해야 한다.

react-query는 개발자 도구도 제공한다. 개발자 도구를 활용하면, 현재 캐시된 쿼리와 상태를 쉽게 확인할 수 있어 디버깅에 용이하다. 별도의 패키지로 분리되어 있으며, 추가로 설치해야 한다.

```bash
npm install @tanstack/react-query-devtools
```

설정법은 간단한데, `QueryClientProvider` 하위에 `ReactQueryDevtools` 컴포넌트를 추가해주면 된다.

```tsx
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* 앱 컴포넌트 */}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

`initialIsOpen` 옵션을 통해 개발자 도구의 초기 열림 상태를 지정할 수 있으며, 기본값은 `false`이다. 기타 옵션은 [공식 문서](https://tanstack.com/query/v5/docs/framework/react/devtools)를 참고하면 된다.

기본적인 설정은 끝났고, 이제 react-query의 주요 기능들에 대해 알아보자.

### useQuery

`useQuery`는 react-query에서 가장 기본이 되는 훅으로, 데이터를 가져오기 위한 기본 도구임.

API 요청을 처리하면서도 로딩, 에러, 데이터 상태를 자동으로 관리해주기 떄문에 `useEffect`와 `useState`를 직접 조합하는 것보다 훨씬 간결함.

(예제 코드 - useQuery 사용 예시)

코드는 훅에 옵션을 전달하고, 반환된 상태를 활용해 로딩, 에러, 데이터를 처리함.

`useQuery`는 다음과 같은 상태를 반환함

반환값 몇 개 설명(isLoading, isError, data, error, refetch )

isLoading, isFetching 차이

( gif - isLoading과 isFetching의 차이? )

`useQuery`는 다음과 같은 인자를 받음

인자 몇 개 설명( queryKey, queryFn, select, enabled )

쿼리 키 설명 및 설계

- 문자열 vs 배열
- 배열에 변수도 적용할 수 있음

queryFn 설명

select 설명

enabled 설명

placeholderData 설명

( gif - data가 placeholderData로 초기화 되는 것 )

keepPreviousData 언급

( gif - 데이터 로딩 도중 이전 데이터가 유지되는 것 )

initialData 설명

이를 활용한다면, API를 호출해 데이터를 가져오는 작업을 훨씬 깔끔하게 선언할 수 있고, 필요한 상태를 쉽게 활용할 수 있음.

### useMutation

`useQuery`가 데이터를 조회하는데 사용된다면, `useMutation`은 데이터를 생성, 수정, 삭제하는데 사용됨.

`useQuery`와 달리 `useMutation`은 호출 시점에 데이터를 가져오는 것이 아니라, 반환되는 함수를 호출해 데이터를 처리함.

또한, 생성, 수정, 삭제의 경우에는 일반적으로 서버의 데이터를 변경하는 작업이므로, 요청에 대한 캐싱은 수행되지 않는다는 특징이 있다.

(예제 코드 - useMutation 사용 예시)

반환값 설명

- mutate, mutateAsync 및 두 개의 차이점
- isLoading, isError, isSuccess, data, error, isIdle

`useMutation`은 다음과 같은 인자를 받음

- variables
- onSuccess, onError, onSettled

이를 활용해, API를 호출하는 행위를 훨씬 간결하게 선언할 수 있고, 필요한 상태를 쉽게 활용할 수 있음.

### 캐싱

캐싱은 동일한 요청을 반복적으로 호출할 때, 이미 가져온 데이터를 재사용하는 기능임. 이를 활용한다면 불필요한 네트워크 요청을 줄이는 데에 도움을 줌.

react-query는 요청에 대한 응답을 자동으로 캐싱하며, 동일한 요청에 대해 캐시된 데이터를 반환하는 기능을 가지고 있다.

캐싱은 queryClient 단위로 관리되며, queryClient를 제공한 Provider 하위 컴포넌트에 공유된다.

캐싱은 `queryKey`를 기준으로 관리되며, 동일한 `queryKey`에 대해 캐시된 데이터를 재사용함.

캐싱 상태 및 기본 개념( fresh, stale, inactive, garbage collected )

추가로 stale 일 때 refetch 되는 타이밍

- stale 상태에서 컴포넌트 마운트
- stale 상태에서 윈도우 포커스/네트워크 재연결
- 수동 호출(refetch)

staleTime, gcTime(cacheTime) 설명

(캐싱 다이어그램 - fresh, stale, inactive, garbage collected 상태 변화)

데이터 받아오면 fresh, 시간 지나면 stale, refetch되면 다시 fresh됨

이 때, 스테일이 된 데이터를 요청하면 바로 캐시된 데이터 반환 + 백그라운드에서 refetch 실행해 데이터를 갱신

(캐싱 다이어그램 - 스테일타임이 지나기 전과, 지난 후의 작동 방식)

이는 이전 데이터라도 빠르게 보여주면서, 백그라운드에서 최신 데이터를 가져와 갱신하는 UX를 제공함

그리고 모든 컴포넌트의 구독이 끊기면 inactive, 일정 시간 지나면 garbage collected

캐싱을 이해하면 react-query의 동작을 이해하는데 많은 도움이 됨.

react-query는 단순히 데이터를 저장하는데 그치지 않고, 신선도를 관리하면서 네트워크 요청을 최적화한다는 점을 알 수 있음

하지만 캐시된 데이터는 서버의 데이터와 다를 수 있음. 새로운 데이터가 서버에 반영되었을 때, 캐시된 데이터는 여전히 이전 상태일 수 있음.

그래서 필요에 따라 캐시를 무효화하거나 다시 데이터를 가져오는 전략이 필요함.

### 쿼리 무효화 전략

앞서 살펴본 것 처럼, react-query는 데이터를 캐싱함. 하지만 서버의 데이터가 변경되었을 때, 캐시된 데이터는 더 이상 유효하지 않을 수 있음.

그래서 react-query는 쿼리의 캐시를 무효화하거나, 직접 다시 호출하는 기능을 제공함.

이를 적절히 활용한다면, 서버와 클라이언트의 데이터 일관성을 유지하는데 도움을 줄 수 있음.

invalidateQueries는 특정 쿼리 키에 해당하는 캐시를 무효화시킴. 즉, stale 상태로 전환시킴

그리고 다음번에 해당 쿼리를 사용하는 컴포넌트가 마운트되거나 refetch가 발생할 때 때 다시 데이터를 가져오도록 함.

(예제 코드)

DevTool을 확인해보면, 버튼을 누른 시점에 캐시가 stale 상태로 바뀌는 것을 확인할 수 있음.

(gif - 버튼 딸깍 하면 stale 상태로 바뀌는 것)

refetchQueries는 특정 쿼리 키에 해당하는 쿼리를 즉시 다시 호출함

그래서 invalidateQueries와 달리, 즉시 데이터를 갱신하고자 할 때 사용됨.

(예제 코드)

버튼을 누르면 즉시 데이터를 다시 가져오는 것을 확인할 수 있음.

(gif - 버튼 딸깍 하면 네트워크 요청이 다시 발생하는 것)

정리하자면, invalidateQueries는 캐시를 무효화시키고, 다음번에 다시 데이터를 가져오도록 함. refetchQueries는 즉시 데이터를 다시 가져오도록 함.

따라서 변경된 정보를 빠르게 반영하고자 할 때는 refetchQueries를, 다음번에 데이터를 다시 가져오도록 하고 싶을 때는 invalidateQueries를 사용하는 것이 적절함.

이 두 가지 전략을 상황에 맞게 활용한다면 캐싱된 데이터와 실제 서버 데이터를 효과적으로 일치시킬 수 있음.

### 핵심 사용 흐름

지금까지 react-query의 주요 기능들을 살펴 보았다.

useQuery를 통해 데이터를 조회하고, useMutation을 통해 데이터를 생성, 수정, 삭제할 수 있다는 것을 알게 되었다. 그리고 react-query의 캐싱 메커니즘과 함께 이를 무효화할 수 있는 전략도 알아보았다.

이들은 각각의 기능만으로 충분히 유용한 기능을 제공한다. 하지만 함께 조합해서 사용할 경우 더욱 강력한 기능을 발휘할 수 있다.

특정 데이터를 불러오는 쿼리가 있고, 이 데이터를 수정하는 뮤테이션이 있다고 가정해보자.

(예제 코드 - useQuery와 useMutation이 함께 사용되는 예시)

데이터를 수정하는 뮤테이션이 성공적으로 완료되면, 위의 쿼리를 업데이트하여 최신 상태를 반영하고 싶을 수 있음.

이런 경우 갱신 하고 싶은 `useQuery`에서 반환된 `refetch` 함수를 호출해 데이터를 다시 가져오도록 할 수 있음.

(예제 코드 - 뮤테이션 성공 시 refetch 호출)

하지만 `refetch`를 직접 호출할 수 없는 경우, 예를 들어 `useQuery`와 `useMutation`이 서로 다른 컴포넌트에 있을 때는 어떻게 해야 할까? 아니면 여러 개의 쿼리를 한 번에 갱신하고 싶을 때는?

이 때 바로 invalidateQuery와 refetchQueries를 활용할 수 있다.

(예제 코드 - 뮤테이션 성공 시 invalidateQueries 호출)

뮤테이션이 완료됬을 때, queryClient의 invalidateQueries를 호출해 특정 쿼리를 무효화시킨다. 그러면 해당 쿼리의 캐시는 stale 상태가 되고, 특정 시점에 업데이트 되며 최신 데이터를 반영하게 된다. 혹은 refetchQueries를 호출해 즉시 데이터를 다시 가져오도록 할 수도 있다.

결국 `useQuery`, `useMutation`, 그리고 쿼리 무효화는 하나의 사이클을 형성해 서로 연동될 수 있다. `useQuery`는 데이터를 가져와 화면에 보여주고, `useMutation`은 사용자의 동작을 서버에 반영하며, 쿼리 무효화는 변경된 결과가 다시 조회되도록 하는 역할을 한다.

이 세가지가 맞물려 동작할 때, 데이터를 불러오고 수정하고 최신 상태를 반영하는 과정이 매끄럽게 이어지며 클라이언트와 서버 간 데이터 일관성을 자연스럽게 유지할 수 있는 흐름을 만들어준다.

실제로 간단한 TODO 리스트를 통해서 실제 흐름을 한 번 확인해보자.

TODO 리스트를 불러오는 쿼리가 `/`에 있다.

(예제 코드 - TODO 리스트 불러오는 컴포넌트)

TODO 아이템을 추가하는 뮤테이션이 `/add`에 있다. 이 페이지에서 작업을 완료하면 `/`로 돌아가도록 한다.

(예제 코드 - TODO 아이템 추가하는 컴포넌트)

`/add`에서 아이템을 추가하고 나면, `/`로 돌아왔을 때 최신 상태가 반영되어야 한다. 하지만, TODO 목록의 캐시는 여전히 이전 상태일 수 있다.

(gif - TODO 아이템 추가 후 돌아왔을 때, 이전 상태가 보이는 것)

이를 해결하기 위해, `/add`에서 아이템을 추가하는 뮤테이션이 성공적으로 완료되면, queryClient의 invalidateQueries를 호출해 TODO 리스트 쿼리를 무효화시킨다.

(예제 코드 - 뮤테이션 성공 시 invalidateQueries 호출)

이제 아이템을 추가하고 `/`로 돌아오면, TODO 리스트 쿼리가 stale 상태가 되고, 컴포넌트가 마운트되면서 다시 데이터를 가져오게 된다. 그 결과, 최신 상태가 반영된 TODO 리스트를 볼 수 있다.

(gif - TODO 아이템 추가 후 돌아왔을 때, 최신 상태가 반영되는 것)

### 마무리

이번 글에서는 react-query를 공부하면서 알게 된 내용을 정리해보았음.

처음에 react-query는 단순하게 API 처리를 편하게 하는 도구로만 생각했음. 사이드 프로젝트에 도입하기도 했는데, 그 때에도 단순히 캐싱 기능을 활용하는 정도로만 사용했음

그런데 생각보다 많은 기능과 활용도가 있다는 것을 알게 되었고, 엄청 유용한 도구라는 생각을 하게 되었음. 특히 서버와 클라이언트의 데이터 일관성을 유지하는데 많은 도움을 줄 수 있다는 점이 인상적이었음.

react-query에 대한 기능을 사용해볼 수 있는 기회가 있었으면 좋겠음

시간이 된다면, 이 글에서 다루지 못했던 react-query를 활용한 더 다양한 기능에 대해서도 정리해보고 싶음
