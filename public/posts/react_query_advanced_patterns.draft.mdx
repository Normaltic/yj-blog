---
title: react-query 활용하기
date: 2025-10-04 22:00:00
summary: Optimistic Update, Infinite Scroll, Suspense 등
---

react-query는 서버 상태를 관리하는 강력한 도구로, 데이터 페칭, 캐싱, 동기화 및 업데이트를 간편하게 처리할 수 있게 해준다.

사이드 프로젝트를 진행하면서 클라이언트에서의 데이터 패칭과 상태 제어를 위해 react-query를 도입하였다. 이 라이브러리를 학습하면서 작성한 [react-query로 데이터 페칭 제어하기](https://blog.yunji.kim/study_about_react_query) 에서는, react-query의 기본적인 개념과 사용법, 옵션들을 정리하였다.

하지만 react-query는 단순히 데이터 페칭과 상태 제어를 넘어 더 다양한 기능들을 제공한다. 이를 활용하면 병렬 요청을 수행하거나 낙관적 업데이트를 구현하는 등, 보다 복잡한 시나리오에서도 효과적으로 서버 상태를 관리할 수 있다.

이번 글에서는 이전 글에서 다루지 않은 react-query의 여러 기능들과 함께, 그 기능들을 활용하는 방법을 소개하고자 한다.

### Parallel Query

`useQuery`를 사용하면 데이터를 페칭하여 불러올 수 있다. 그리고 한 페이지에서 여러 개의 데이터를 불러와야 할 수도 있다.

이 경우 `useQuery`를 여러 번 선언해 각각의 요청을 관리할 수 있다.

(예시 코드 - 복수개의 useQuery)

하지만 이 방식은 각 쿼리를 개별적으로 다뤄야 한다. 그래서 필요한 경우 각 상태를 일일이 확인하고 처리해야 한다.

(예시 코드 - isLoading or isError 처리)

위 코드는 두 개의 쿼리를 관리하는 예시이다. 각 로딩과 에러의 상태를 개별적으로 확인하고 처리해야 한다.

몇 개 까지는 괜찮겠지만, 쿼리의 개수가 많아지면 많아질 수록 문제가 생긴다. 코드가 길어지고, 상태 관리가 복잡해지며, 유지보수가 어려워진다.

각 퀄의 로딩과 에러 상태를 일관되게 관리하기 어려워진다. 모든 상태를 일일이 조합해야 하므로 코드가 복잡해지고, 화면 단위의 상태 판단도 까다로워진다.

이를 해결하기 위해 복수 개의 쿼리를 처리하기 위해 `useQueries` 훅을 사용할 수 있다.

#### useQueries

useQueries에 대한 설명

`useQueries`는 여러 개의 쿼리를 한 번에 선언하고 관리할 수 있게 해주는 훅이다.

(예시 코드 - useQueries)

여러 쿼리를 하나의 훅에서 관리할 수 있음.

배열의 아이템은 각 쿼리의 설정 객체, 즉 `useQuery`의 옵션 객체와 동일한 형태

접근 시 각 쿼리의 상태를 배열로 접근 가능

`useQueries`는 그래서 단순하게, 마치 `Promise.all`를 사용하는 것 처럼, 여러 개의 `useQuery` 호출을 병렬로 처리할 수 있게 해주는 것 처럼 보인다.

그런데, 단순히 병렬 요청을 처리하는 것이고 배열로 상태를 반환하기 때문에, 각 쿼리의 상태를 개별적으로 확인하고 처리해야 한다는 점은 동일하다. 다른 글에서는 실제로 단순히 복수개의 `useQuery`와 동일하다는 이야기도 보았다.

그러나 `combine` 옵션을 활용한다면, `useQueries` 사용 이유를 더욱 명확하게 할 수 있다.

> `combine` 옵션은 react-query v5에 추가된 기능이다.

(예시 코드 - combine 옵션)

이를 활용하면 전달한 쿼리들의 결과를 조합하여 새로운 객체를 반환할 수 있다.

(예시 코드 - combine 결과 활용)

각 쿼리를 묶어 **하나의 상태로 관리**할 수 있다.

그래서 `combine` 옵션을 사용한다면, 단순히 여러 쿼리를 병렬로 실행하는 것에 그치지 않고, 여러 쿼리의 결과를 하나로 묶어 관리할 수 있다.

`combine` 옵션은 다음과 같은 경우에 다시 실행된다.

- 쿼리의 데이터가 변경될 때
- `combine` 함수가 변경될 때

즉, 위 코드처럼 인라인으로 작성된 `combine` 함수는 매 렌더링마다 새로 생성되기 때문에, 쿼리의 데이터가 변경되지 않더라도 매 렌더링마다 `combine` 함수가 변경되어 다시 실행된다.

따라, `combine` 함수를 컴포넌트 바깥으로 빼거나, `useCallback`으로 메모이제이션하는 것이 좋다.

(예시 코드 - useCallback 활용)

#### Dynamic multiple queries

만약, 쿼리를 동적으로 생성해야 하는 경우가 필요할 수 있다.

예를 들어, 여러 개의 ID를 받아 각각의 데이터를 불러와야 하는 경우이다.

이 경우, 복수개의 ID를 받아서 데이터를 반환하는 API가 있다면 단일 쿼리로 해결할 수 있다. 그러나, 그렇지 않은 경우, 각 ID마다 개별 쿼리를 생성해야 한다.

하지만, `useQuery`는 훅이기 때문에 조건문이나 반복문 안에서 호출할 수 없다. 따라서, 동적으로 쿼리를 생성하는 것이 어렵다.

이 때, `useQueries`의 진가가 발휘된다.

`useQueries`는 배열을 인자로 받기 때문에, **동적으로 쿼리를 생성**할 수 있다. 예를 들어, ID 배열을 받아서 각 ID마다 쿼리를 생성할 수 있다.

(예시 코드 - 동적 useQueries)

위 코드에 대한 설명

쿼리의 개수나 key를 런타임에 결정할 수 있음.

동적 쿼리 생성이 필요할 때 매우 유용.

단, key가 중복되지 않도록 주의해야 함. key가 중복될 경우 옵션(`placeHolderData` 등)이 의도치 않게 공유될 수 있음.

`useQueries`는 여러 쿼리를 병렬 처리하는 데 유용하게 사용할 수 있다.

`combine` 통해 여러 쿼리를 하나의 상태로 묶어 관리할 수 있다.

또한, 동적으로 쿼리를 생성해야 하는 경우에도 유용하게 사용할 수 있다.

이를 활용한다면 여러 쿼리를 하나로 묶거나, 동적으로 쿼리를 생성하는 등의 다양한 시나리오에서 효과적으로 서버 상태를 관리할 수 있다.

결국 `useQueries`는 여러 쿼리를 하나의 패턴으로 묶거나, 동적으로 생성해야 하는 요청을 유연하게 제어할 수 있는 훅이다. 복잡한 데이터 요청 흐름 속에서도 일관된 형태로 서버 상태를 관리할 수 있게 해준다.

### Cancellation

사용자가 화면을 이동할 경우 이전 요청은 더 이상 유효하지 않게 된다. 이 경우, 이전 요청을 취소하여 불필요한 네트워크 요청을 방지해야 한다.

또한, 특정 요청을 직접 취소하고 싶은 경우도 있을 수 있다.

그래서 쿼리와 뮤테이션을 취소해야 하는 상황에서는 어떻게 해야 할까?

#### Query

기본적으로 `useQuery`는 컴포넌트가 언마운트될 때 자동으로 쿼리를 취소한다.

이는 쿼리가 더 이상 필요하지 않을 때 불필요한 네트워크 요청을 방지하기 위함이다.

그러나 수동으로 쿼리를 취소하고 싶은 경우도 있을 수 있다.

`queryClient.cancelQueries` 메서드를 사용하여 특정 쿼리를 취소할 수 있다.

(예시 코드 - cancelQueries)

이 메서드는 쿼리 키를 인자로 받아 해당 쿼리를 취소한다.

단, 이 메서드는 쿼리의 상태를 `canceled`로 변경하지만, 실제 네트워크 요청을 취소하지는 않는다.

따라서 네트워크 요청도 취소하기 위한 추가적인 작업이 필요하다.

이를 위해 `queryFn`에서 전달되는 `AbortController`를 활용할 수 있다.

(예시 코드 - queryFn 명세)

`fetch` API는 `AbortController`를 지원함. 그래서 `signal`을 `fetch`에 전달하여 요청을 취소할 수 있다.

(예시 코드 - fetch에 signal 전달)

`axios`는 기본적으로 `AbortController`를 지원하지 않지만, `cancelToken`을 활용하여 요청을 취소할 수 있다.

(예시 코드 - axios cancelToken 활용)

#### Mutation

`useMutation`은 데이터를 변경하는 요청을 처리하며, 함수를 호출하는 시점에 요청이 시작된다.

데이터를 변경하는 요청을 취소하고 싶은 경우가 있을 수 있다.

그러나, `useMutation`에서는 요청을 취소하는 기능이 기본적으로 제공되지 않는다.

따라서, `useMutation`에서 요청을 취소하려면 `AbortController`를 활용하여 직접 구현해야 한다.

(예시 코드 - useMutation에서 AbortController 활용)

위 코드에서 `AbortController`를 생성하고, `mutationFn`에 전달하여 요청을 취소할 수 있다.

### Prefetch Query

프리패치란?

일반적인 프리패치 예시. link hover, 예상되는 페이지 이동 등.

react-query에서도 프리패치를 지원한다.

`queryClient.prefetchQuery` 메서드를 사용하여 쿼리를 미리 불러올 수 있다.

(예시 코드 - prefetchQuery)

이 메서드는 쿼리 키와 쿼리 함수를 인자로 받아 해당 쿼리를 미리 불러온다.

프리패치된 쿼리는 캐시에 저장되며, 이후 동일한 쿼리 키로 요청할 때 캐시된 데이터를 즉시 반환한다.

프리패치는 사용자가 특정 작업을 수행하기 전에 데이터를 미리 불러와, 사용자 경험을 향상시키는 데 유용하다.

예를 들어, 사용자가 특정 링크를 클릭할 것으로 예상되는 경우, 해당 링크에 마우스를 올렸을 때 프리패치를 수행하여, 사용자가 클릭했을 때 즉시 데이터를 표시할 수 있다.

(예시 코드 - link hover 시 prefetch)

### Optimistic update

사용자의 요청은 다양하게 일어날 수 있다. 댓글을 작성하거나, 좋아요 버튼을 누르거나, 게시글을 삭제하는 등의 작업이 있다.

이러한 작업은 서버에 요청을 보내고, 서버의 응답을 기다린 후에야 화면에 반영된다.

그러나, 사용자의 네트워크 환경이 좋지 않거나 서버의 응답이 지연되는 경우, 사용자는 긴 대기 시간을 경험하게 된다.

(투두 토글 예제)

이를 해결하기 위해 낙관적 업데이트라는 패턴을 사용할 수 있다.

낙관적 업데이트(Optimistic Update)란, 서버의 응답을 기다리지 않고, 사용자의 요청이 성공할 것이라고 가정하고, 즉시 화면에 반영하는 패턴이다.

서버 반영 전에 사용자가 변화를 인지할 수 있어, 더 빠르고 부드러운 사용자 경험을 제공할 수 있다.

cancel → snapshot → setQueryData → rollback/commit

장점과 리스크

### Infinite Scroll

많은 양의 데이터를 받아오는 경우, 이를 페이지네이션으로 나누어 불러오는 경우가 있음.

그러나 페이지네이션은 사용자가 페이지를 이동해야 하므로, 사용자 경험이 떨어질 수 있음.

이를 해결하기 위해 무한 스크롤(Infinite Scroll) 패턴을 사용할 수 있다.

무한 스크롤에 대한 설명

react-query에서는 `useInfiniteQuery` 훅을 제공하여 무한 스크롤을 쉽게 구현할 수 있게 해준다.

#### useInfiniteQuery

useInfiniteQuery 구조

##### Options

useInfiniteQuery options

##### Returns

useInfiniteQuery returns

#### Implementation

무한 스크롤 구현

### Suspense & ErrorBoundary

react-query는 데이터를 가져오는 과정을 내부적으로 상태로 관리.

하지만 로딩과 에러 상태를 조건문으로 일일이 처리하는 것은 번거로울 수 있음.

이를 해결하기 위해 react-query는 `suspense` 모드와 `ErrorBoundary`를 지원.

#### Suspense

react-query 의 `suspense` 모드 설명

`suspense` 모드를 활성화하면, 쿼리가 로딩 중일 때 컴포넌트가 렌더링되지 않고, 대신 상위의 `Suspense` 컴포넌트가 렌더링됨.

(예시 코드)

위 코드에서 `suspense: true` 옵션을 설정하면, 쿼리가 로딩 중일 때 컴포넌트가 렌더링되지 않고, 대신 상위의 `Suspense` 컴포넌트가 렌더링됨.

#### ErrorBoundary

마찬가지로, 쿼리에서 발생한 에러는 `ErrorBoundary` 컴포넌트에서 처리할 수 있음.

`ErrorBoundary` 컴포넌트는 자식 컴포넌트에서 발생한 에러를 잡아 처리할 수 있는 컴포넌트임.

react-query는 suspense 모드와 함께 사용할 때, 쿼리 에러를 `throw`하여 `ErrorBoundary`에서 잡을 수 있게 해줌.

(예시 코드)

위 코드에서 `ErrorBoundary` 컴포넌트는 쿼리에서 발생한 에러를 잡아 처리함.

#### Caution

react-query의 `suspense`모드를 통해 데이터를 로딩하는 동안 컴포넌트가 렌더링되지 않도록 할 수 있음.

해당 모드에서는 에러를 상태로 관리하지 않고 `throw`하기 때문에, `ErrorBoundary`와 함께 사용하여 에러를 처리해야 함.

이 패턴을 활용하면, 로딩과 에러 상태를 컴포넌트 내부에서 조건문으로 일일이 처리하지 않고, 더 간결하고 명확한 코드로 서버 상태를 관리할 수 있음.

다만, 주의해야 할 사항이 있음.

우선, `suspense` 모드는 에러를 상태로 관리하지 않기 때문에, `ErrorBoundary`와 함께 사용해야 함. 그렇지 않으면 에러가 잡히지 않아 애플리케이션이 크래시될 수 있음.

또한, 한 컴포넌트에서 여러 개의 쿼리를 사용하는 경우에는 정상작동하지 않을 수 있음. 첫 번째 쿼리가 내부적으로 `Promise`를 반환하기 때문에, 다른 쿼리가 실행되기 전에 컴포넌트를 일시 중단하기 때문.

이 경우에는 `useQueries` 훅을 사용하여 여러 쿼리를 하나로 묶어 관리하는 것이 좋음. 혹은 별도의 컴포넌트로 분리하여 각각의 쿼리를 독립적으로 관리하는 것도 방법.

### 마치며

1편: 기초 & 옵션 → 2편: 확장/제어/UX 패턴

React Query는 “서버 상태 제어 도구”라는 메시지 강화

마무리 & 3편 예고

### 참고

- [[ TanStack Query ] TanStack Query로 Infinite scroll 기능 구현하기](https://programmerplum.tistory.com/205)
