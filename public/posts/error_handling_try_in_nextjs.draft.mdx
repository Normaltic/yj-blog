---
title: Next.js 서버 요청 실패 핸들링 해보기
date: 2025-04-17 17:00:00
summary: 서버 컴포넌트가 데이터 통신에 실패했다.
---

Next.js 의 서버 컴포넌트에 대한 설명. 서버 컴포넌트에서는 데이터를 요청할 수도 있다.

그런데 요청이 실패할 경우가 있다. 그럴 때는 페이지가 정상적으로 불러와지지 않는다. Next.js에서는 error.tsx나 ErrorBoundary를 통해 에러를 잡아 fallback UI 를 보여준다. 하지만 다시 시도하기 같은 기능은 제공하지 않는다.

그래서, 랜더링에 실패한 컴포넌트를 어떻게 핸들링하면 좋을지, 다시 시도하기가 가능한지 알아보면서 고민한 과정을 정리하고자 한다.

### error.tsx와 ErrorBoundary

다음과 같은 코드가 있다. 초록색 화면은 정적인 컨텐츠이고, 오른쪽 아래는 데이터를 받아와 보여주는 영역이다.

// 코드

// 화면 사진

데이터를 받아오는 코드는 아래와 같다. 랜덤 숫자를 뽑아, 5 이상일 때에는 통과, 5 미만일 때에는 실패로 처리하는 로직을 적용했다.

페이지에서 에러가 발생하면, 넥스트의 기본 에러 화면이 출력된다.

// 에러 사진

`error.tsx`를 설정한다면, 원하는 화면을 출력할수가 있다.

에러가 발생한 영역 단위로 핸들링을 하고 싶을 경우, 에러 바운더리를 설정하면 하위 트리에 대한 에러를 감지할 수 있다.

// 에러 바운더리 코드

componentDidCatch는 하위 컴포넌트, 즉 자식 컴포넌트에서 에러가 발생했을 때 에러를 감지한다. 자기 자신에게서 발생한 에러는 캐치하지 못한다. 이를 활용해서 자식 컴포넌트에서 발생한 에러를 잡을 수 있다.

// 에러 바운더리 적용 코드

그리고 에러가 발생할 경우, fallback 을 통해 에러가 발생할 경우 원하는 화면을 보여줄 수 있다.

`error.tsx`와 `ErrorBoundary`를 사용해서, 에러가 발생했을 때 예외 처리를 할 수 있다는 걸 알게 되었다. 하지만 에러 메세지를 보여줄 수는 있는데, 재요청을 할 수는 없다.

서버 컴포넌트에서 요청에 실패했을 때, 다시 요청을 하려면 어떻게 해야할까?

### 클라이언트 컴포넌트로 처리

가장 쉬운 방법은, 요청을 클라이언트 컴포넌트에서 처리하는 것이다.

// 클라이언트 컴포넌트 코드

컴포넌트가 마운트됬을 때 데이터를 불러와, 결과에 따라 결과 화면이나 재요청 UI를 노출하는 형식이다.

그런데 이건 서버 컴포넌트에서의 해결 방법은 아닌 것 같다. 물론 필요한 경우 충분히 사용 가능한 방법이지만, 원하는 방식은 아니다.

### 컴포넌트 두 개 만들기

다음으로 생각했던건, 컴포넌트를 두 개 만드는 것이다.

서버 컴포넌트에서 먼저 데이터를 요청하고, 실패하면 클라이언트 컴포넌트를 랜더링하게 하는 방식이다.

// 서버 컴포넌트 코드

데이터 요청을 하고, 데이터 요청 성공 시에는 목표로 한 컴포넌트를 랜더링하고, 실패할 경우 재요청 로직이 작성되어 있는 클라이언트 컴포넌트를 랜더링하도록 하는것이다.

이렇게 하면 최초 서버에서 요청을 하고, 실패했을 때 클라이언트 컴포넌트를 랜더링 해 재요청 로직이나 로딩 표시등을 구현할 수 있게 된다. 원하는 방식으로 작동하는 것이다.

그러나 이는 처리하고 싶은 서버 컴포넌트와 똑같은 클라이언트 컴포넌트를 다시 작성해두어야 한다. 데이터를 요청하는 컴포넌트가 한두개도 아닐 것이기 때문에 상당히 번거로울 것 같다고 생각했다.

그렇다면 이걸 추상화해서 간단하게 사용할 방법은 없을까?

### 재요청 컴포넌트 추상화 해보기

> 결과부터 말하자면 성공하지 못했고, 시도했던 흔적을 남기기 위해 기록했다.

데이터를 불러오는 로직과, 그걸 필요로 하는 컴포넌트를 전달해서, 위에서 했던 서버 컴포넌트와 클라이언트 컴포넌트를 추상화 하는것을 시도해보았다.

컴포넌트를 실행해서 전달하거나, 컴포넌트 자체를 전달하는 것에는 조금 제약이 있다. 데이터 요청과 그 데이터를 참조하는 컴포넌트의 랜더링은 한 곳에서 이어져야 한다. 그래야 컴포넌트에 데이터를 전달할 수 있기 때문이다. 그리고 컴포넌트에 요청에 대한 결과 대신, 다른 속성(`className` 등)을 할당해야 할 수도 있다. 그래서 컴포넌트를 직접 전달하는것 보다 `renderProps`를 사용해 보기로 했다.

// 클라이언트 컴포넌트 추상화 코드

로딩 표현을 위한 상태와 데이터, 에러를 저장하는 상태를 선언하고, 데이터 패칭 함수를 선언한다. 그리고 데이터가 없거나 에러가 발생했을 때, 재요청 버튼을 노출시키고 재요청하게 한다. 데이터를 정상적으로 불러오면, 전달받은 `render` 함수를 실행하도록 했다.

서버 컴포넌트 역시 추상화했다

// 서버 컴포넌트 추상화 코드

데이터 요청을 하고, 성공했을 경우 `render`함수를 실행하고, 실패한다면 클라이언트 컴포넌트를 출력하여 클라이언트에서 처리하도록 한다.

결과는..

// 에러 사진.

서버 컴포넌트에서 클라이언트 컴포넌트로는 함수를 전달하지 못한다는 내용이다.

Next.js의 서버 컴포넌트는 브라우저가 아닌 서버에서 실행되며, HTML을 생성해서 클라이언트로 전달하는 구조다. 이때 클라이언트 컴포넌트가 props를 통해 서버 컴포넌트로부터 데이터를 전달받는 경우, Next.js는 그 데이터를 직렬화(serialization) 해서 브라우저로 전송하게 된다.

즉, 서버 컴포넌트에서 클라이언트 컴포넌트로 전달되는 props는 반드시 serializable해야 한다. JSON으로 표현 가능한 데이터만 전달할 수 있기 때문에, 함수는 전달할 수 없다. 그래서 `ferher`, `render` 함수를 전달해 에러가 발생하는 것이다.

따라서, `renderProps`를 사용해서 구현하는 것은 불가능했다.

### 새로 고침을 통한 갱신

// https://edspencer.net/2024/7/16/errors-and-retry-with-react-server-components 참고해서 쓰기

router.refresh는 서버에 새 요청을 하고, 데이터 요청을 다시 가져오고, 서버 컴포넌트를 다시 렌더링한다. 클라이언트는 영향을 받지 않은 클라이언트 측 React(예: useState) 또는 브라우저 상태(예: 스크롤 위치)를 잃지 않고 업데이트된 React 서버 컴포넌트 페이로드를 병합한다.

이를 ErrorBoundary와 결합하면 구현할 수 있다.

단, 상태를 유지한다고 하더라도 페이지를 새로고침하는 것이기 떄문에, 다른 구간에도 영향이 갈 수 있다

### 마치며

Next.js 에서 어떻게 에러를 핸들링 하면 좋을지 궁금해져서 테스트 해본 내용을 정리해봤음. 단순히 에러를 보여주는 것만으론 부족하다고 느껴서, ‘그럼 다시 시도는 어떻게 하지?’라는 궁금증에서 출발했다.

직접 구현해보니 서버 컴포넌트 특성상 제약도 많았고, 예상보다 쉽게 되진 않았지만 그래도 불가능한 것은 아니라는걸 알 수 있었다.

결국 중요한 건 “어떤 컴포넌트가 데이터를 책임질지”를 명확히 정하고, 실패했을 때 사용자 경험을 어떻게 설계할 것인가에 대한 고민인 것 같다.
